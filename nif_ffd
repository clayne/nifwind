/**** BEGIN LICENSE BLOCK ****

BSD 3-Clause License

Copyright (c) 2023, the wind.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

**** END LICENCE BLOCK ****/

// Origin: "nif.xml" checkout f265c56482c728c6877e45d5b5993d3bff83670a at
//         https://github.com/niftools/nifxml.git
//
// Later modifications are ineligible and plain wrong IMHO. You could create
// independent projects for each one of the new versions you're interested in.

// Highlighter: C#

// Describe a .nif. This is the common ground from which the different variants
// shall be formed.
// The purpose of this file is to test the correctness of the "nif.xml"
// transformation and to update my libffd to deal with the new constructs
// required (or even make it more scalable by updating its design for custom
// extensions).
// Then this file shall be split into different .nif versions to the best of my
// ability. Then you can get these, or the big mess, and create projects for
// them; they shall remain as immutable templates in this project.
// Its way better to manage simple files, and let the code merge them on the
// fly - when needed: for example modifying version x FFD will no longer damage
// version y FFD.
//
// This instance is crafted by hand, because a parser generator at the 1st run
// will prevent me recalling "nif.xml". The funny thing is "github" is
// recognizing this text as C - I'm "flattered", but this ain't C; I created
// a "nif.xml" to C parser generator a long time ago - find it if you need
// read-only speed.
// There will be xml2ffd and ffd2xml for the ones who prefer XML - no worries :)

// Machine types ...............................................................

type uint 4
type int -4
type short -2
type ushort 2
type byte 1
type char byte
type bool byte (Version > 0x04010001)
type bool int  (Version <= 0x04010001)
type float .4 //TODO implement me
type Flags ushort // bit-flags
type Ptr int // -ptr
type Ref int // +ptr

// enum .......................................................................

enum TextureAlphaFormat uint
    NONE    0 //
    BINARY  1 // Mask
    SMOOTH  2 // Blend
    DEFAULT 3

enum TextureApplyMode uint
    REPLACE  0 // GL_REPLACE
    DECAL    1 // GL_DECAL
    MODULATE 2 // GL_MODULATE
    HILIGHT  3 // "PS2 Only. Function Unknown."
    HILIGHT2 4 // "Parallax Flag in some Oblivion meshes."

enum TextureType uint //REPLACE {TexType}
    BASE     0 // diffuse
    DARK     1 // "Used to darken the model with false lighting."
    DETAIL   2 // "Combined with base map for added detail."
    GLOSS    3 // specular
    GLOW     4
    BUMP     5
    NORMAL   6
    UNKNOWN2 7
    DECAL_0  8
    DECAL_1  9
    DECAL_2 10
    DECAL_3 11

enum AnimInterpolation uint //REPLACES {KeyType}
    LINEAR       1
    QUADRATIC    2
    TBC          3 // "Tension Bias Continuity"
    XYZ_ROTATION 4 // ! quaternion
    CONST        5 // "Used for visibility keys in NiBoolData."

// "how vertex colors influence lighting"
enum LightMode uint
    EMISSIVE    0
    EMI_AMB_DIF 1 // "Emissive + Ambient + Diffuse."

//TODO to nif_tes4_ffd
enum OblivionHavokMaterial uint
    STONE         0 //TODO the parser: code_repetition-- => pattern: table
    CLOTH         1 //TODO these are sequential: its pointless to specify the
    DIRT          2 //     obvious; besides no one cares if CLOTH is encoded as
    GLASS         3 //     "uint" value of 4; make EnumItem.Value optional:
    GRASS         4 //      - auto-value starts at 0
    METAL         5 //      - auto-value gets invalidated to explicit Item.Value
    ORGANIC       6 //      - you get exception reward for non-distinctiveness
    SKIN          7
    WATER         8
    WOOD          9
    ROCK         10
    HEAVY_METAL  11
    HEAVY_WOOD   12
    CHAIN        13
    SNOW         14
    STONE_STAIRS       15 //LATER R&D: Whats with all the stairs? Check with the
    CLOTH_STAIRS       16 //           mod creation tool (can't recall its name)
    DIRT_STAIRS        17
    GLASS_STAIRS       18
    GRASS_STAIRS       19
    METAL_STAIRS       20
    ORGANIC_STAIRS     21
    SKIN_STAIRS        22
    WATER_STAIRS       23
    WOOD_STAIRS        24
    HEAVY_STONE_STAIRS 25
    HEAVY_METAL_STAIRS 26
    HEAVY_WOOD_STAIRS  27
    CHAIN_STAIRS       28
    SNOW_STAIRS        29
    ELEVATOR 30
    RUBBER   31

//TODO to nif_fo3_ffd
/* "Bit 5: flag for PLATFORM (for values 32-63 -32 to know material number)
    Bit 6: flag for STAIRS (for values 64-95: -64)
    Bit 5+6: flag for STAIRS+PLATFORM (for values 96-127: -96)" */
enum Fallout3HavokMaterial uint
    STONE
    CLOTH
    DIRT
    GLASS
    GRASS
    METAL                5
    ORGANIC
    SKIN
    WATER
    WOOD
    HEAVY_STONE         10
    HEAVY_METAL
    HEAVY_WOOD
    CHAIN
    BOTTLECAP
    ELEVATOR            15
    HOLLOW_METAL
    SHEET_METAL
    SAND
    BROKEN_CONCRETE
    VEHICLE_BODY        20
    VEHICLE_PART_SOLID
    VEHICLE_PART_HOLLOW
    BARREL
    BOTTLE
    SODA_CAN            25
    PISTOL
    RIFLE
    SHOPPING_CART
    LUNCHBOX
    BABY_RATTLE         30
    RUBBER_BALL

//TODO to nif_tes5_ffd
enum SkyrimHavokMaterial uint
    STONE          3741512247 // <- looks like a hash function; Dear, Wizards?
    CLOTH          3839073443
    DIRT           3106094762
    GLASS          3739830338
    GRASS          1848600814
    // METAL ? //TODO FFD::SNode::ParseEnum(): skip comment lines
    ORGANIC        2974920155
    SKIN            591247106
    WATER          1024582599
    WOOD            500811281
    // other 1-word ones
    GRAVEL          428587608
    BOTTLE          493553910
    BARREL          732141076
    BASKET          790784366
    ICE             873356572
    BOOK           1264672850
    CARPET         1286705471
    MUD            1486385281
    SAND           2168343821
    DRAGON         2518321175
    BONE           3049421844
    COIN           3589100606
    ARROW          3725505938
    HEAVY_STONE    1570821952
    HEAVY_METAL    2229413539
    HEAVY_WOOD     3070783559
    CHAIN          3074114406
    SNOW            398949039
    STAIRS_STONE    899511101 // Interesting
    STONE_STAIRS   1886078335 //
    STAIRS_BROKEN_STONE 2892392795
    STAIRS_WOOD    1461712277 // ??
    WOOD_STAIRS    1803571212 //
    STAIRS_SNOW    1560365355
    // new
    BROKEN_STONE    131151687
    SOLID_METAL    1288358971
    CHAIN_METAL     438912228
    LIGHT_WOOD      365420259
    BOTTLE_SMALL   2025794648
    CERAMIC_MEDIUM  781661019
    SKIN_SMALL     2632367422
    SKIN_LARGE     2965929619
    //
    BOULDER_SMALL  1550912982
    BOULDER_LARGE  1885326971
    BOULDER_MEDIUM 4283869410
    //
    BOWS_STAVES    1607128641
    AXE_1HAND      1305674443
    BLUNT_2HAND    3969592277
    BLADE_2HAND    2022742644
    BLADE_1HAND    1060167844
    BLADE_1HAND_SMALL 2617944780
    //
    SHIELD_LIGHT   3448167928
    SHIELD_HEAVY   3702389584
    ARMOR_LIGHT    3424720541
    ARMOR_HEAVY    3708432437
    //
    UNKNOWN_1      1028101969 // "draugr\character assets\skeletons.nif"
    UNKNOWN_2      1440721808 // "draugr\draugrbootsfemale_go.nif"
    UNKNOWN_3      1574477864 // "dragon\character assets\skeleton.nif"
    UNKNOWN_4      1591009235 // "deer\character assets\skeleton.nif"

// Mesh color. "Anything higher than 57 is also null."
//TODO to nif_tes4_ffd
enum OblivionLayer byte
    UNIDENTIFIED // white
    STATIC       // red
    ANIM_STATIC  // magenta
    TRANSPARENT  // light pink
    CLUTTER      // light blue
    WEAPON       // orange
    PROJECTILE   // light orange
    SPELL        // cyan
    BIPED        // green
    TREES        // light brown
    PROPS        // magenta
    WATER        // cyan
    TRIGGER      // light grey
    TERRAIN      // light yellow
    TRAP         // light grey
    NONCOLLIDABLE   // white
    CLOUD_TRAP      // greenish grey
    GROUND          //TODO "none"? - what color is this ?
    PORTAL          // green
    STAIRS          // white
    CHAR_CONTROLLER // yellow
    AVOID_BOX       // dark yellow
    UNKNOWN1        // white
    UNKNOWN2        // white
    CAMERA_PICK     // white
    ITEM_PICK       // white
    LINE_OF_SIGHT   // white
    PATH_PICK       // white
    CUSTOM_PICK_1   // white
    CUSTOM_PICK_2   // white
    SPELL_EXPLOSION // white
    DROPPING_PICK   // white
    OTHER           // white
    HEAD
    BODY
    SPINE1
    SPINE2
    L_UPPER_ARM
    L_FOREARM
    L_HAND
    L_THIGH
    L_CALF
    L_FOOT
    R_UPPER_ARM
    R_FOREARM
    R_HAND
    R_THIGH
    R_CALF
    R_FOOT
    TAIL
    SIDE_WEAPON
    SHIELD
    QUIVER
    BACK_WEAPON
    BACK_WEAPON2
    PONYTAIL
    WING
    NULL // OblivionLayer

//TODO to nif_fo3_ffd
enum Fallout3Layer byte
    UNIDENTIFIED   // white
    STATIC         // red
    ANIM_STATIC    // magenta
    TRANSPARENT    // light pink
    CLUTTER        // light blue
    WEAPON         // orange
    PROJECTILE     // light orange
    SPELL          // cyan
    BIPED          // green
    TREES          // light brown
    PROPS          // magenta
    WATER          // cyan
    TRIGGER        // light grey
    TERRAIN        // light yellow
    TRAP           // light grey
    NONCOLLIDABLE  // white
    CLOUD_TRAP     // greenish grey
    GROUND         // none
    PORTAL         // green
    DEBRIS_SMALL   // white
    DEBRIS_LARGE   // white
    ACOUSTIC_SPACE // white
    ACTORZONE      // white
    PROJECTILEZONE // white
    GASTRAP        // yellowish green
    SHELLCASING    // white
    TRANSPARENT_SMALL // white
    INVISIBLE_WALL // white
    TRANSPARENT_SMALL_ANIM // white
    BIPED          // green
    CHARCONTROLLER // yellow
    AVOIDBOX       // orange
    COLLISIONBOX   // white
    CAMERASPHERE   // white
    DOORDETECTION  // white
    CAMERAPICK     // white
    ITEMPICK       // white
    LINEOFSIGHT    // white
    PATHPICK       // white
    CUSTOMPICK1    // white
    CUSTOMPICK2    // white
    SPELLEXPLOSION // white
    DROPPINGPICK   // white
    NULL           // white
    OTHER          // white
    HEAD
    BODY
    SPINE1
    SPINE2
    L_UPPER_ARM
    L_FORE_ARM
    L_HAND
    L_THIGH
    L_CALF
    L_FOOT
    R_UPPER_ARM
    R_FORE_ARM
    R_HAND
    R_THIGH
    R_CALF
    R_FOOT
    TAIL
    SHIELD
    QUIVER
    WEAPON
    PONYTAIL
    WING
    PACK
    CHAIN
    ADDONHEAD
    ADDONCHEST
    ADDONARM
    ADDONLEG // Fallout3Layer

enum SkyrimLayer byte
    UNIDENTIFIED
    STATIC
    ANIMSTATIC
    TRANSPARENT
    CLUTTER // "Object with this layer will float on water surface."
    WEAPON
    PROJECTILE
    SPELL
    BIPED
    TREES
    PROPS
    WATER
    TRIGGER
    TERRAIN
    TRAP
    NONCOLLIDABLE
    CLOUD_TRAP
    GROUND
    PORTAL
    DEBRIS_SMALL
    DEBRIS_LARGE
    ACOUSTIC_SPACE
    ACTORZONE
    PROJECTILEZONE
    GASTRAP
    SHELLCASING
    TRANSPARENT_SMALL
    INVISIBLE_WALL
    TRANSPARENT_SMALL_ANIM
    WARD
    CHARCONTROLLER
    STAIRHELPER
    DEADBIP
    BIPED_NO_CC
    AVOIDBOX
    COLLISIONBOX
    CAMERASHPERE
    DOORDETECTION
    CONEPROJECTILE
    CAMERAPICK
    ITEMPICK
    LINEOFSIGHT
    PATHPICK
    CUSTOMPICK1
    CUSTOMPICK2
    SPELLEXPLOSION
    DROPPINGPICK
    NULL // SkyrimLayer

// "if MOPP Data is organized into chunks (PS3) or not (PC)"
enum MoppDataBuildType byte
    CHUNK
    NO_CHUNK
    NOT_SET

//REPLACE {MipMapFormat}
enum MipMaps uint // Omitting "Texture" prefix, since the name implies it.
    NO //TODO clarify: does this specify input or render texture state
    YES
    DEFAULT

// NiPixelData
enum PixelFormat uint
    RGB8
    RGBA8
    PAL8     // NiPalette
    DXT1 4
    DXT5     // DXT3? - or some re-invented wheel?
    DXT5_ALT //

// NiSourceTexture
enum PixelLayout uint
    PAL8
    HIGH_COLOR_16 // color-plane bits?
    TRUE_COLOR_32 // color-plane bits?
    COMPRESSED    // format?
    BUMPMAP       // how many bits?
    PAL4
    DEFAULT

enum TextureClampMode uint //REPLACE {TexClampMode}
    CLAMP_S_CLAMP_T
    CLAMP_S_WRAP_T
    WRAP_S_CLAMP_T
    WRAP_S_WRAP_T

enum TextureFilter uint //REPLACE {TexFilterMode}
     NEAREST  // GL_NEAREST
     BILERP   // GL_LINEAR
     TRILERP
     NEAREST_MIPNEAREST // GL_NEAREST_MIPMAP_NEAREST
     NEAREST_MIPLERP    // GL_NEAREST_MIPMAP_LINEAR
     BILERP_MIPNEAREST  // GL_LINEAR_MIPMAP_LINEAR

enum VertMode uint // vertex colors
     IGNORE   // "Source Ignore"
     EMISSIVE // "Source Emissive"
     AMB_DIF  // "Source Ambient/Diffuse"

enum CycleType uint // "animation cycle behavior"
    LOOP
    REVERSE
    CLAMP

enum FieldType uint // "force field's type"
    WIND
    POINT

enum BillboardMode ushort // the way a billboard reacts to a camera
    ALWAYS_FACE_CAMERA
    ROTATE_ABOUT_UP
    RIGID_FACE_CAMERA
    ALWAYS_FACE_CENTER
    RIGID_FACE_CENTER
    BSROTATE_ABOUT_UP
    ROTATE_ABOUT_UP2 9

enum StencilCompareMode uint //TODO
    NEVER
    LESS
    EQUAL
    LEQUAL
    GREATER
    NEQUAL
    GEQUAL
    ALWAYS

enum ZCompareMode uint // depth
    ALWAYS
    LESS
    EQUAL
    LEQUAL
    GREATER
    NEQUAL
    GEQUAL
    NEVER

enum StencilAction uint
    KEEP
    ZERO
    REPLACE
    INCREMENT
    DECREMENT
    INVERT

enum FaceDrawMode uint
    CCW_OR_BOTH
    CCW
    CW
    DOUBLE_SIDED

/* "4 (Box) is used for everything movable.
    7 (Keyframed) is used on statics and animated stuff." */
enum MotionSystem byte
    INVALID
    DYNAMIC /* "A fully-simulated, movable rigid body. At construction time the
            engine checks the input inertia and selects SPHERE_INERTIA or
            BOX_INERTIA as appropriate" */
    SPHERE // "Simulation is performed using a sphere inertia tensor"
    SPHERE_INERTIA /* This is the same as SPHERE, except that simulation of the
                   rigid body is "softened" */
    BOX // "Simulation is performed using a box inertia tensor"
    BOX_STABILIZED /* This is the same as BOX, except that simulation of the
                   rigid body is "softened" */
    KEYFRAMED /* "Simulation is not performed as a normal rigid body. The
              keyframed rigid body has an infinite mass when viewed by the rest
              of the system. (used for creatures)" */
    FIXED /* "This motion type is used for the static elements of a game scene,
          e.g. the landscape. Faster than MO_SYS_KEYFRAMED at velocity 0. (used
          for weapons)" */
    THIN_BOX /* "A box inertia motion which is optimized for thin boxes and has
             less stability problems" */
    CHARACTER /* "A specialized motion used for character controllers" */

enum DeactivatorType byte
    INVALID
    NEVER   // "This will force the rigid body to never deactivate"
    SPATIAL /* "Tells Havok to use a spatial deactivation scheme. This makes use
            of high and low frequencies of positional motion to determine when
            deactivation should occur" */

/* "A list of possible solver deactivation settings. This value defines how the
        solver deactivates objects. The solver works on a per object basis.
        Note: Solver deactivation does not save CPU, but reduces creeping of
        movable objects in a pile quite dramatically." */
enum SolverDeactivation byte
    INVALID
    OFF
    LOW // "Very conservative deactivation, typically no visible artifacts"
    MEDIUM // "no serious visible artifacts in most cases"
    HIGH // "visible artifacts"
    MAX // "visible artifacts"

enum MotionQuality byte
    INVALID
    FIXED     // "fixed bodies"
    KEYFRAMED // "moving objects with infinite mass"
    DEBRIS
    MOVING    // "moving bodies, which should not leave the world"
    CRITICAL  /* "all objects, which you cannot afford to tunnel through the
              world at all" */
    BULLET    // "very fast objects"
    USER
    CHARACTER // "character controllers"
    KEYFRAMED_REPORT /* "Use this for moving objects with infinite mass which
                     should report contact points and Toi-collisions against all
                     other bodies, including other fixed and keyframed bodies"
                     */

enum ForceType uint
    PLANAR
    SPHERICAL
    UNKNOWN

// NiTextureTransformController
enum TextureTransform uint //REPLACE {TexTransform}
    TRANSLATE_U
    TRANSLATE_V
    ROTATE
    SCALE_U
    SCALE_V

// NiPSysBombModifier
enum DecayType uint
    NONE
    LINEAR
    EXPONENTIAL

// NiPSysBombModifier
enum SymmetryType uint
    SPHERICAL
    CYLINDRICAL
    PLANAR

/* "Controls the way the a particle mesh emitter determines the starting speed
 and direction of the particles that are emitted" */
enum VelocityType uint
    NORMALS
    RANDOM
    DIRECTION

enum EmitFrom uint // mesh emitter
    VERTICES
    FACE_CENTER
    EDGE_CENTER
    FACE_SURFACE
    EDGE_SURFACE

// NiTextureEffect
enum EffectType uint
    PROJECTED_LIGHT
    PROJECTED_SHADOW
    ENVIRONMENT_MAP
    FOG_MAP

enum TextureCoordGenType uint //REPLACE {CoordGenType}
    WORLD_PARALLEL // planar
    WORLD_PERSPECTIVE
    SPHERE_MAP
    SPECULAR_CUBE_MAP
    DIFFUSE_CUBE_MAP

enum Endianess byte
    BIG
    LITTLE

// NiPoint3InterpControllers
enum TargetColor ushort
    AMBIENT
    DIFFUSE
    SPECULAR
    SELF_ILLUM

// NiGeometryData
enum ConsistencyType ushort
    MUTABLE       0
    STATIC   0x4000
    VOLATILE 0x8000

enum SortingMode uint
    INHERIT
    OFF

enum PropagationMode uint
    SUCCESS
    FAILURE
    ALWAYS
    NEVER

enum CollisionMode uint
    BOUNDING_BOX
    TRIANGLES
    ALTERNATE_BOUNDING_VOLUMES
    NO_TEST
    NIBOUND

enum BoundVolumeType int
    BASE -1 //TODO EnumItem.Value could be < 0
    SPHERE
    BOX
    CAPSULE
    UNION
    HALFSPACE

enum hkResponseType byte
    INVALID
    SIMPLE_CONTACT // "Do normal collision resolution"
    REPORTING // "No collision resolution is performed but listeners are called"
    NONE

//TODO to nif_tes5_ffd; to nif_fo3_ffd
/* "Biped bodypart data used for visibility control of triangles.  Options are
 Fallout 3, except where marked for Skyrim (uses SBP prefix)
 Skyrim BP names are listed only for vanilla names, different creatures have
 different defnitions for naming." */
enum BSBodyPartType ushort
    BP_TORSO
    BP_HEAD
    BP_HEAD2
    BP_LEFTARM
    BP_LEFTARM2
    BP_RIGHTARM
    BP_RIGHTARM2
    BP_LEFTLEG
    BP_LEFTLEG2
    BP_LEFTLEG3
    BP_RIGHTLEG
    BP_RIGHTLEG2
    BP_RIGHTLEG3
    BP_BRAIN
    SBP_HEAD 30
    SBP_HAIR
    SBP_BODY
    SBP_HANDS
    SBP_FOREARMS
    SBP_AMULET
    SBP_RING
    SBP_FEET
    SBP_CALVES
    SBP_SHIELD
    SBP_TAIL
    SBP_LONGHAIR
    SBP_CIRCLET
    SBP_EARS
    SBP_DRAGON_BLOODHEAD_OR_MOD_MOUTH
    SBP_DRAGON_BLOODWINGL_OR_MOD_NECK
    SBP_DRAGON_BLOODWINGR_OR_MOD_CHEST_PRIMARY
    SBP_DRAGON_BLOODTAIL_OR_MOD_BACK
    SBP_MOD_MISC1
    SBP_MOD_PELVIS_PRIMARY
    SBP_DECAPITATEDHEAD
    SBP_DECAPITATE
    SBP_MOD_PELVIS_SECONDARY
    SBP_MOD_LEG_RIGHT
    SBP_MOD_LEG_LEFT
    SBP_MOD_FACE_JEWELRY
    SBP_MOD_CHEST_SECONDARY
    SBP_MOD_SHOULDER
    SBP_MOD_ARM_LEFT
    SBP_MOD_ARM_RIGHT
    SBP_MOD_MISC2"
    SBP_FX01
    BP_SECTIONCAP_HEAD 101
    BP_SECTIONCAP_HEAD2
    BP_SECTIONCAP_LEFTARM
    BP_SECTIONCAP_LEFTARM2
    BP_SECTIONCAP_RIGHTARM
    BP_SECTIONCAP_RIGHTARM2
    BP_SECTIONCAP_LEFTLEG
    BP_SECTIONCAP_LEFTLEG2
    BP_SECTIONCAP_LEFTLEG3
    BP_SECTIONCAP_RIGHTLEG
    BP_SECTIONCAP_RIGHTLEG2
    BP_SECTIONCAP_RIGHTLEG3
    BP_SECTIONCAP_BRAIN
    SBP_130_HEAD 130
    SBP_131_HAIR
    SBP_141_LONGHAIR 141
    SBP_142_CIRCLET
    SBP_143_EARS
    SBP_150_DECAPITATEDHEAD 150
    BP_TORSOCAP_HEAD 201
    BP_TORSOCAP_HEAD2
    BP_TORSOCAP_LEFTARM
    BP_TORSOCAP_LEFTARM2
    BP_TORSOCAP_RIGHTARM
    BP_TORSOCAP_RIGHTARM2
    BP_TORSOCAP_LEFTLEG
    BP_TORSOCAP_LEFTLEG2
    BP_TORSOCAP_LEFTLEG3
    BP_TORSOCAP_RIGHTLEG
    BP_TORSOCAP_RIGHTLEG2
    BP_TORSOCAP_RIGHTLEG3
    BP_TORSOCAP_BRAIN
    SBP_230_HEAD 230
    BP_TORSOSECTION_HEAD       1000
    BP_TORSOSECTION_HEAD2      2000
    BP_TORSOSECTION_LEFTARM    3000
    BP_TORSOSECTION_LEFTARM2   4000
    BP_TORSOSECTION_RIGHTARM   5000
    BP_TORSOSECTION_RIGHTARM2  6000
    BP_TORSOSECTION_LEFTLEG    7000
    BP_TORSOSECTION_LEFTLEG2   8000
    BP_TORSOSECTION_LEFTLEG3   9000
    BP_TORSOSECTION_RIGHTLEG  10000
    BP_TORSOSECTION_RIGHTLEG2 11000
    BP_TORSOSECTION_RIGHTLEG3 12000
    BP_TORSOSECTION_BRAIN     13000 // BSBodyPartType

// <bitflags/>
enum BSSegmentFlags uint //TODO reason?
    BSSEG_WATER 9

//TODO to nif_tes(3|4|5)_ffd
// BSLightingShaderProperty
//REPLACE {BSLightingShaderPropertyShaderType}
enum name="BS_LS_ShaderType" uint
    Default
    EnvironmentMap // "EnvMap Mask(TS6), EnvMap Scale"
    GlowShader // "Glow(TS3)"
    Heightmap // "Height(TS4)"
    FaceTint  // "SubSurface(TS3), Detail(TS4), Tint(TS7)"
    SkinTint
    HairTint
    ParallaxOccMaterial // "Enables Height(TS4), Max Passes, Scale"
    WorldMultitexture
    WorldMap1
    Unknown_10
    MultiLayerParallax /* "Enables EnvMap Mask(TS6), Layer(TS7), Parallax Layer
                       Thickness, Parallax Refraction Scale, Parallax Inner
                       Layer U Scale, Parallax Inner Layer V Scale, EnvMap
                       Scale" */
    Unknown_12
    WorldMap2
    SparkleSnow // "SparkleParams"
    WorldMap3
    Eye Envmap // "EnvMap Mask(TS6), Eye EnvMap Scale"
    Unknown_17
    WorldMap4
    WorldLODMultitexture

// BSEffectShaderProperty animated variable
enum EffectShaderControlledVariable uint
    EmissiveMultiple
    FalloffStartAngle // degress
    FalloffStopAngle  // degrees
    FalloffStartOpacity
    FalloffStopOpacity
    Alpha
    UOffset
    UScale
    VOffset
    VScale

enum EffectShaderControlledColor uint
    EmissiveColor

// BSLightingShaderProperty
enum LightingShaderControlledVariable uint
    Refraction Strength
    EnvironmentMapScale 8
    Glossiness
    SpecularStrength
    EmissiveMultiple
    Alpha
    UOffset 20
    UScale
    VOffset
    VScale

// BSLightingShaderProperty
enum LightingShaderControlledColor uint
    Specular
    Emissive

enum ExtraVectorsFlags byte
    None
    Tangents_Bitangents 16

enum hkConstraintType uint
    BallAndSocket
    Hinge
    Limited Hinge
    Prismatic 6
    Ragdoll
    StiffSpring

// "Furniture entry points. It specifies the direction(s) from where the actor
// is able to enter (and leave) the position."
enum FurnitureEntryPoints ushort // bitflags
    Front
    Behind
    Right
    Left
    Up

// "Animation type used on this position. This specifies the function of this
// position."
enum AnimationType ushort
    Sit   1
    Sleep 2
    Lean  4

// "Determines how the raw image data is stored in NiRawImageData"
enum ImageType uint
    RGB  1
    RGBA 2

// "Editor flags for the Body Partitions"
enum BSPartFlag ushort // bitflags
    EDITOR_VISIBLE
    START_NET_BONESET 8

// const ......................................................................

// These are incomplete. They shall be complete at their respective ffd.
// see what falls out: grep -r... sort -u
const NIF_HEADER_STRING_1 "NetImmerse File Format" (Version <= 0x0a000100)
const NIF_HEADER_STRING_2 "Gamebryo File Format" (Version >= 0x0a010000)

// I could do this:
const VER_FOO (Version == 34)
// and re-create the same mess with (VER_FOO); I'm not doing this - the idea
// is to decouple the FFD from this program, and let different communities
// manage their favorite FFDs

// struct - "compound" ........................................................

// "A variable length string that ends with a newline character (0x0A)."
struct HeaderString
    char Chars[-10] //TODO implement me: read until char[i] == 10

struct SizedString
    char Value[uint]

struct String
    SizedString        Value (Version <= 0x14000005)
    int<>SizedString[] Value (Version >= 0x14010003) // Header.Strings Index

struct ByteArray
    byte Data[uint]

struct ByteMatrix
    uint Num1
    uint Num2
    byte Data[Num2][Num1] //LATER handle >1 implicit N; or not

struct Color3
    float Value[3] // r,g,b

struct ByteColor3
    byte Value[3] // r,g,b

struct Color4
    float Value[4] // r,g,b,a

struct ByteColor4
    byte Value[4] // r,g,b,a

struct FilePath
    SizedString        Value (Version <= 0x14000005)
    int<>SizedString[] Value (Version >= 0x14010003) // Header.Strings index

struct Footer
    // "If there is a camera, for 1st person view, then this NIF object is
    //  referred to as well in this list"
    Ref Root[uint] (Version >= 0x0303000D)

// "The distance range where a specific level of detail applies."
struct LODRange
    float Near
    float Far
    uint  Unknown[3] (Version <= 0x03010000)

struct MatchGroup // "Group of vertex indices of vertices that match"
    ushort Indices[ushort]

struct Vector3
    float Value[3] // x,y,z

struct Vector4
    float Value[4] // x,y,z,w

struct Quaternion
    float Value[4] // w,x,y,z

struct QuaternionXYZW
    float Value[4] // x,y,z,w

struct Matrix22
    float Value[2][2] // matrices are NxM - it is as simple as that

struct Matrix33
    float Value[3][3]

struct Matrix44
    float Value[4][4]

//TODO all these "struct" with one field - do something about it, after the
//     split

struct MipMap // NiPixelData
    uint Width  // [?] - pixels/apples/pears ?
    uint Height // [?]
    uint Offset // [?]

struct NodeGroup // NiNodes
    Ptr Nodes[uint]

struct ShortString
    char Value[byte] // 0-terminated (its length includes the 0)

struct SkinShape
    Ptr Shape        // NiTriBasedGeom
    Ref SkinInstance // NiSkinInstance

struct SkinShapeGroup
    // "First link is a NiTriShape object"
    // "Second link is a NiSkinInstance object"
    SkinShape LinkPairs[uint]

struct SkinWeight // "A weighted vertex" TODO rename-me
    ushort Index
    float  Weight

struct AVObject
    SizedString Name
    Ptr         AVObject // NiAVObject

/* "In a .kf file, this links to a controllable object, via its name (or for
 version 10.2.0.0 and up, a link and offset to a NiStringPalette that
 contains the name), and a sequence of interpolators that apply to this
 controllable object, via links." */
struct ControllerLink
    // "Name of a controllable object in another NIF file"
    String TargetName (Version <= 0x0a010000)
    Ref    Controller (Version <= 0x0a010000) // NiTimeController
    Ref    Interpolator (Version >= 0x0a01006a) // NiInterpolator
    Ref    Controller (Version >= 0x0a01006a) // NiTimeController
    Ref    Unknown1 (Version == 0x0a01006a)
    ushort Unknown2 (Version == 0x0a01006a)
    // Idle animations tend to have low values for this, and NIF objects that
    // have high values tend to correspond with the important parts of the
    // animation
    byte   Priority (Version >= 0x0a01006a && UVersion2 >= 10)
    // NiStringPalette; things like this one demand split by version; this is
    // just the tip of the iceberg - there are truly scary things below (like
    // conditions at HavokColFilter): read on
    Ref    StringPalette ((Version >= 0x0a020000) && (Version <= 0x14000005))
    //
    // -/__ Such walls of text shall cease to exist with the split _/--
    //
    // The name of the animated node
    String NodeName ((Version == 0x0a01006a) || (Version >= 0x14010003))
    // index at the above StringPalette; StringPalette had a SizedString
    // containing a set of zero-terminated strings
    int<>String[] NodeName ((Version >= 0x0a020000) && (Version <= 0x14000005))
    String        PropType ((Version == 0x0a01006a) || (Version >= 0x14010003))
    int<>String[] PropType ((Version >= 0x0a020000) && (Version <= 0x14000005))
    String        CtllrType ((Version == 0x0a01006a) || (Version >= 0x14010003))
    int<>String[] CtllrType ((Version >= 0x0a020000) && (Version <= 0x14000005))
    String        Variable1 ((Version == 0x0a01006a) || (Version >= 0x14010003))
    int<>String[] Variable1 ((Version >= 0x0a020000) && (Version <= 0x14000005))
    String        Variable2 ((Version == 0x0a01006a) || (Version >= 0x14010003))
    int<>String[] Variable2 ((Version >= 0x0a020000) && (Version <= 0x14000005))

struct ExportInfo
    ShortString Value[uint] (Version >= 0x0a000102) /* if this proves wrong
    uint Unknown (Version >= 0x0a000102)
    ShortString Author
    ShortString Info1
    ShortString Info2*/

struct Block
    uint Zero (Version <= 0x0A01006A)
    //TODO implement variadic fields: hash[hash] a.k.a. dynamic value list:
    //     the value list is not at the FFD but at the file data; matching
    //     by struct name only
    ... struct<>BlockName<>BlockHash // for key at BlockHash get BlockName[key]

// ((Version >= 0x0303000D) && (Version < 0x05000001))
struct BlockX
    SizedString Name
    ... struct<>Name

format nif // this is a "Header" no more; this is the entire file
    [NifVersionString] // initialize Version TODO field attributes
    HeaderString Signature
    // Catch: Version is parsed from Signature
    HeaderString Copyright[3] (Version <= 0x03010000)
    uint         Version // Replace. Option: Stop On Version Mishmash
    Endianess   Endianess (Version >= 0x14000004)
    uint        UVersion  (Version >= 0x0a010000) //REPLACE {User Version}
    uint        NumBlocks (Version >= 0x0303000D) // num serialized objects
    //REPLACE {User Version 2}
    uint        UVersion2 ((Version >= 0x0a010000) && ((UVersion >= 10)
                           || ((UVersion == 1) && (Version != 0x0a020000))))
    uint        Unknown1  (Version >= 0x1e000002)
    ExportInfo  Info      (Version == 0x0a000102)
    ExportInfo  Info      ((Version >= 0x0a010000) && ((UVersion >= 10)
                           || ((UVersion == 1) && (Version != 0x0a020000))))
    SizedString BlockName[ushort]    (Version >= 0x0a000100) // distinct
    // "The upper bit appears to be a flag used for PhysX block types."?
    ushort      BlockHash[NumBlocks] (Version >= 0x0a000100) // file order
    uint        BlockSize[NumBlocks] (Version >= 0x14020007) // [bytes] IIRC
    uint        NumStrings           (Version >= 0x14010003)
    uint        MaxStringLength      (Version >= 0x14010003)
    SizedString Strings[NumStrings]  (Version >= 0x14010003)
    uint        Unknown2             (Version >= 0x0a000100)
    Block  Blocks[NumBlocks] (Version >= 0x0a000100)
    BlockX Blocks[NumBlocks] ((Version >= 0x0303000D) && (Version < 0x05000001))
    Footer Footer            (Version >= 0x0303000D)
    //TODO (Version < 0x0303000D)

struct StringPalette
    SizedString Palette // 0-terminated strings list
    uint        Length //TODO its total length or number of strings?

struct TBC // "Tension, bias, continuity"
    float Value[3] // t,b,c

/* "A generic key with support for interpolation. Type 1 is normal linear
 interpolation, type 2 has forward and backward tangents, and type 3 has
 tension, bias and continuity arguments. Note that color4 and byte always seem
 to be of type 1." */
//TODO implement struct parameters: the parser should be able to transform it:
// Key<float,Interpolation> becomes:
// struct Key1
//     float Time
//     float Value
//     float Forward  (Interpolation == 2)
//     float Backward (Interpolation == 2)
//     TBC   TBC      (Interpolation == 3),
// but is it worth it?
// Key struct: NiKeyframeData
struct Key<T,A>
    float Time
    T     Value
    T     Forward  (A == 2)
    T     Backward (A == 2)
    TBC   TBC      (A == 3)

// "Array of vector keys (anything that can be interpolated, except rotations)"
struct KeyGroup<T>
    uint                 NumKeys
    AnimInterpolation    Interpolation (NumKeys)
    Key<T,Interpolation> Keys[NumKeys]

// "A special version of the key type used for quaternions. Never has tangents"
struct QuatKey<A>
    float Time       (Version <= 0x0a010000)
    float Time       ((Version >= 0x0a01006a) && (A != 4))
    Quaternion Value (A != 4)
    TBC        TBC   (A == 3)

struct TextureCoord //REPLACE {TexCoord}
    float Value[2] // u,v

struct TDTextureTransform
    TextureCoord Translation
    TextureCoord Tiling
    float        WRotation
    uint         TType
    TextureCoord Center

struct TextureDesc  //REPLACE {TexDesc}
    [NifRef(NiSourceTexture)] //PERHAPS
    Ref Source // NiSourceTexture
    TextureClampMode ClampMode  (Version <= 0x14000005)
    TextureFilter    FilterMode (Version <= 0x14000005)
    // "0xYZ00 = clamp mode Y, filter mode Z"
    Flags Flags    (Version >= 0x14010003)
    short Unknown1 (Version >= 0x14060000)
    uint  UVSet    (Version <= 0x14000005) // NiGeometryData set
    // "Freedom Force docs, &quot;L values can range from 0 to 3 and are used to
    // specify how fast a texture gets blurry&quot;"
    short PS2_L    (Version <= 0x0a040001)
    // "Freedom Force docs, &quot;The K value is used as an offset into the
    // mipmap levels and can range from -2047 to 2047. Positive values push the
    // mipmap towards being blurry and negative values make the mipmap
    // sharper.&quot;"
    short PS2_K     (Version <= 0x0a040001)
    ushort Unknown2 (Version <= 0x0401000C)
    TDTextureTransform ((bool) && (Version >= 0x0a010000))

struct ShaderTexDesc
    bool        IsUsed
    TextureDesc TextureData (IsUsed)
    uint        MapIndex    (IsUsed)

struct TexSource
    byte UseExternal
    FilePath FileName (UseExternal == 1)
    Ref      Unknown1 ((UseExternal == 1) && (Version >= 0x0a010000))
    byte     Unknown2 ((UseExternal == 0) && (Version <= 0x0a000100))
    FilePath FileName ((UseExternal == 0) && (Version >= 0x0a010000))
    Ref      Bitmap   (UseExternal == 0) // NiPixelData

struct Triangle
    ushort Value[3] // v1,v2,v3

// "Skinning data for a submesh, optimized for hardware skinning. Part of
// NiSkinPartition."
struct SkinPartition
    ushort VNum // Num Vertices
    ushort TNum // Num Triangles
    ushort BNum // Num Bones
    ushort SNum // Num Strips
    //"The Gamebryo engine seems to work well only if this number is equal to 4"
    ushort WNum // Num Weights Per Vertex
    ushort Bones[BNum]
    bool   HasVertexMap         (Version >= 0x0a010000)
    ushort VMap[VNum]           ((HasVertexMap) || (Version <= 0x0a000102))
    bool   HasVertexWeights     (Version >= 0x0a010000)
    float  VWeights[VNum][WNum] ((HasVertexWeights) || (Version <= 0x0a000102))
    ushort StripLengths[SNum]
    bool   HasFaces             (Version >= 0x0a010000)
    //TODO implement jagged arrays
    ushort Strips[SNum][StripLengths] ((SNum != 0) && ((HasFaces)
                                       || (Version <= 0x0a000102)))
    Triangle Triangles[TNum]          ((SNum == 0) && ((HasFaces)
                                       || (Version <= 0x0a000102)))
    byte   BoneIndices[VNum][WNum] (bool)
    ushort Unknown1 (UVersion >= 12)

struct Transform<T> // QTransform, MTransform
    Vector3 Translation
    T       Rotation
    float   Scale

struct SkinTransform
    Matrix33 Rotation
    Vector3  Translation
    float    Scale

struct BoundingBox
    uint     Unknown1
    Vector3  Translation
    Matrix33 Rotation
    Vector3  Radius

struct FurniturePosition
    Vector3 Offset
    ushort  Orientation  (UVersion <= 11)
    // "Refers to a furnituremarkerxx.nif file"
    byte    PositionRef1 (UVersion <= 11)
    byte    PositionRef2 (UVersion <= 11)
    float         Heading  ((Version >= 0x14020007) && (UVersion >= 12))
    AnimationType AType    ((Version >= 0x14020007) && (UVersion >= 12))
    FurnitureEntryPoints F ((Version >= 0x14020007) && (UVersion >= 12))

struct hkTriangle // "A triangle with extra data used for physics"
    Triangle Triangle
    ushort   WeldingInfo
    Vector3  Normal (Version <= 0x14000005)

struct Morph<A> // "Geometry morphing data component"
    String                   Name          (Version >= 0x0a01006a)
    uint                     KNum          (Version <= 0x0a010000)
    AnimInterpolation        Interpolation (Version <= 0x0a010000)
    Key<float,Interpolation> Keys[KNum]    (Version <= 0x0a010000)
    uint Unknown1 ((Version >= 0x0a01006a) && (Version <= 0x0a020000))
    uint Unknown2 ((Version >= 0x14000004) && (Version <= 0x14000005))
    Vector3 Vectors[A]

struct Particle
    Vector3 Velocity
    Vector3 Unknown1
    float   Lifetime
    float   Lifespan
    float   Timestamp
    ushort  Unknown2
    ushort  VertexID

struct SkinData<A>
    // "Offset of the skin from this bone in bind position"
    SkinTransform STransform
    // "Translation offset of a bounding sphere holding all vertices. (Note that
    // its a Sphere Containing Axis Aligned Box not a minimum volume Sphere)"
    Vector3    BoundingSphereOffset
    float      BoundingSphereRadius
    short      Unknown[13] ((Version == 0x14030009) && (UVersion == 131072))
    ushort     VNum
    SkinWeight VertexWeights[VNum] ((Version <= 0x04020100)
                                   || ((Version >= 0x04020200) && (A != 0)))

struct SphereBV
    Vector3 Center
    float Radius

// "ColFilter property for Havok. It contains Layer, Flags and Part Number"
struct HavokColFilter
    // scary; I'm not sure I want to program my parser to handle such
    // expressions because writing them means you have an error in your design;
    // I can hardly express the amount of pointless the next 3 fields represent.
    OblivionLayer Layer ((Version != 0x14020007)
                        || ((Version == 0x14020007)
                            && (UVersion  != 11)
                            && (UVersion  != 12)
                            && (UVersion2 != 34)
                            && (UVersion2 != 83)
                           )
                        )
    Fallout3Layer Layer ((Version == 0x14020007) && (UVersion == 11)
                        && (UVersion2 == 34))
    SkyrimLayer   Layer ((Version == 0x14020007) && (UVersion == 12)
                        && (UVersion2 == 83))
    // 0xe - flags; 0x1f - part number; see the origin for more details
    byte FlagsPartNumber
    ushort Unknown1

struct HavokMaterial
    OblivionHavokMaterial Material ((Version != 0x14020007)
                                   || ((Version == 0x14020007)
                                       && (UVersion  != 11)
                                       && (UVersion  != 12)
                                       && (UVersion2 != 34)
                                       && (UVersion2 != 83)
                                      )
                                   )
    Fallout3HavokMaterial Material ((Version == 0x14020007) && (UVersion == 11)
                                   && (UVersion2 == 34))
    SkyrimHavokMaterial   Material ((Version == 0x14020007) && (UVersion == 12)
                                   && (UVersion2 == 83))

struct OblivionSubShape // "Havok Information for packed TriStrip shapes"
    HavokColFilter HavokColFilter
    uint           VNum
    HavokMaterial  Material

struct MotorDescriptor
    float Unknown1[6]
    byte  Unknown2

// "This constraint defines a cone in which an object can rotate. The shape of
// the cone can be controlled in two (orthogonal) directions"
struct RagdollDescriptor
    // "Oblivion"
    // A{Pivot,Plane,Twist}, B{<-}
    Vector4 Value[6] (Version <= 0x14000005)
    // "Fallout 3"
    // A{Twist,Plane,Motor,Pivot}, B{<-}
    Vector4 Value[8] ((Version >= 0x14020007) && (UVersion2 > 16))
    // A{Pivot,Plane,Twist}, B{<-}
    Vector4 Value[6] ((Version >= 0x14020007) && (UVersion2 == 16))
    float ConeMaxAngle
    float PlaneMinAngle
    float PlaneMaxAngle
    float TwistMinAngle
    float TwistMaxAngle
    float MaxFriction
    MotorDescriptor Md ((bool) && (Version >= 0x14020007) && (UVersion2 > 16))

// "This constraint allows rotation about a specified axis, limited by specified
// boundaries"
struct LimitedHingeDescriptor
    // "Oblivion"
    // A{Pivot,Axle,Perp2 A1,Perp2 A2}, B{Pivot,Axle,Perp2 B2}
    Vector4 Value[7] (Version <= 0x14000005)
    // "Fallout 3"
    // A{Axle,Perp2 A1,Perp2 A2,Pivot}, B{<-}
    Vector4 Value[8]  ((Version >= 0x14020007) && (UVersion2 > 16))
    Vector4 Value[7]  ((Version >= 0x14020007) && (UVersion2 == 16))
    float MinAngle
    float MaxAngle
    float MaxFriction
    MotorDescriptor Md ((bool) && (Version >= 0x14020007) && (UVersion2 > 16))

// "This constraint allows rotation about a specified axis."
struct HingeDescriptor
    // "Oblivion"
    // A{Pivot,Perp2 A1,Perp2 A2}, B{Pivot,Axle}
    Vector4 Value[5] (Version <= 0x14000005)
    // "Fallout 3"
    // A{Axle,Perp2 A1,Perp2 A2,Pivot}, B{<-}
    Vector4 Value[8] (Version >= 0x14020007)

struct BallAndSocketDescriptor
    byte    Unknown1
    Vector3 Unknown2[2]
    int     Unknown3

struct PrismaticDescriptor
    // "Oblivion"
    // A{Pivot,RMatrix44}, B{Pivot,Sliding,Plane}
    Vector4 Value[8] (Version <= 0x14000005)
    // "Fallout 3"
    // A{Sliding,Rotation,Plane,Pivot}, B{<-}
    Vector4 Value[8] (Version >= 0x14020007)
    float MinDistance
    float MaxDistance
    float Friction
    byte  Unknown (Version >= 0x14020007)

struct StiffSpringDescriptor
    Vector4 Value[2] // PivotA, PivotB
    float   Length

struct OldSkinData // "Used to store skin weights in NiTriShapeSkinController"
    float   VertexWeight
    ushort  VertexIndex
    Vector3 Unknown

struct MultiTextureElement
    bool HasImage
    Ref               Image  (HasImage) // NiImage
    TextureClampMode  Clamp  (HasImage)
    TextureFilterMode Filter (HasImage)
    uint              UVSet  (HasImage)
    short PS2_L ((HasImage)
                && (Version >= 0x03030000) && (Version <= 0x0a020000))
    short PS2_K ((HasImage)
                && (Version >= 0x03030000) && (Version <= 0x0a020000))
    short Unknown ((HasImage) && (Version >= 0x03030000))

struct BoxBV // "Box Bounding Volume"
    Vector3 Center
    Vector3 Axis[3]
    float   Extent[3]

struct CapsuleBV
    Vector3 Center
    Vector3 Origin
    float Unknown[2]

struct HalfSpaceBV
    Vector3 Normal
    Vector3 Center
    float   Unknown

struct BoundingVolume
    BoundVolumeType CollisionType
    SphereBV    BV (CollisionType == 0)
    BoxBV       BV (CollisionType == 1)
    CapsuleBV   BV (CollisionType == 2)
    UnionBV     BV (CollisionType == 4) // <---.
    HalfSpaceBV BV (CollisionType == 5) //     |

struct UnionBV                          //     |
    BoundingVolume BV[uint] //TODO be careful: circular symbol

struct MorphWeight
    Ref   Interpolator // NiInterpolator
    float Weight

struct ArkTexture // "A texture reference used by NiArkTextureExtraData"
    String Name
    int    Unknown1[2]
    Ref    TexturingProperty // NiTexturingProperty
    byte   Unknown2[9]

struct InertiaMatrix
    float Value[3][4]

// "Array of Vectors for Decal placement in BSDecalPlacementVectorExtraData"
struct DecalVectorArray
    short   VNum
    Vector3 Points[VNum]
    Vector3 Normals[VNum]

struct BodyPartList
    BSPartFlag     PartFlag
    BSBodyPartType BodyPart

struct BSSegment // "Bethesda-specific node"
    int            Index // "Index multiplied by 1536 (0x0600)"
    BSSegmentFlags Flags // "Geometry present in the segment"
    byte           Unknown

struct BoneLOD
    uint   Distance
    String Name

// "Per-chunk material, used in bhkCompressedMeshShapeData"
struct bhkCMSDMaterial
    SkyrimHavokMaterial Material
    SkyrimLayer         Layer
    byte                Unknown1
    ushort              Unknown2

// "Triangle indices used in pair with "Big Verts" in a
// bhkCompressedMeshShapeData"
struct bhkCMSDBigTris
    ushort Triangles[3]
    uint   Unknown1
    ushort Unknown2

struct bhkCMSDTransform
    Vector4        Translation
    QuaternionXYZW Rotation

// "Defines subshape chunks in bhkCompressedMeshShapeData"
struct bhkCMSDChunk
    Vector4 Translation
    uint    MaterialIndex
    ushort  Unknown
    ushort  TransformIndex
    ushort  Vertices[uint]
    ushort  Indices[uint]
    ushort  Strips[uint]
    ushort  Indices2[uint]

struct SubConstraint
    hkConstraintType Type
    Ptr Entities[uint] // bhkEntity
    uint Priority
    BallAndSocketDescriptor BallAndSocket (Type == 0)
    HingeDescriptor         Hinge         (Type == 1)
    LimitedHingeDescriptor  LHinge        (Type == 2)
    PrismaticDescriptor     Prismatic     (Type == 6)
    RagdollDescriptor       Ragdoll       (Type == 7)
    StiffSpringDescriptor   StiffSpring   (Type == 8)

struct bhkRDTMalleableConstraint // A malleable constraint.""
    uint Type
    uint Unknown
    Ref  EntityA // NiObject
    Ref  EntityB //
    uint Priority
    HingeDescriptor        Hinge   (Type == 1)
    RagdollDescriptor      Ragdoll (Type == 7)
    LimitedHingeDescriptor LHinge  (Type == 2)

struct bhkRDTConstraint
    uint Type
    uint Unknown
    Ref  EntityA // NiObject
    Ref  EntityB //
    uint Priority
    RagdollDescriptor         Ragdoll             (Type ==  7)
    bhkRDTMalleableConstraint MalleableConstraint (Type == 13)

// niobject ...................................................................

// These are used to identify groups of objects; I'm letting them stay here for
// reference until the transform is complete. This project won't be using them.
//TODO create a distinct list from the test .nifs to see whats what.
// struct NiObject //niobject

struct Ni3dsAlphaAnimator //niobject
    byte Unknown1
    Ref  Base
    uint Num1
    uint Num2
    uint Unknown2[Num1][Num2]

struct Ni3dsAnimationNode //niobject
    String Name
    bool   HasData
    float  Unknown1[21]       (HasData)
    ushort Unknown2           (HasData)
    Ref    SubNode            (HasData)
    float  Unknown3[12]       (HasData)
    uint   Count              (HasData)
    byte   Unknown4[Count][5] (HasData)

struct Ni3dsColorAnimator //niobject
    byte Unknown[184]

struct Ni3dsMorphShape //niobject
    byte Unknown[14]

struct Ni3dsParticleSystem //niobject
    byte Unknown[14]

struct Ni3dsPathController //niobject
    byte Unknown[20]

struct NiParticleModifier //niobject
    Ref Next // NiParticleModifier
    Ptr Controller (Version >= 0x04000002) // NiParticleSystemController

struct NiPSysCollider //niobject
    float Bounce
    bool  CreateOnCollide
    bool  FreeOnCollide
    Ref   Modifier // NiPSysSpawnModifier
    Ptr   Base
    Ref   Next
    Ptr   Collider

// struct bhkRefObject //niobject
// struct bhkSerializable //niobject
// struct bhkShape //niobject

struct bhkWorldObject //niobject
    Ref Shape // bhkShape
    HavokColFilter HavokColFilter

// Such ... slow down the transform. I don't need the empty ... but I do need
// its non-empty "parent".
struct bhkPhantom //niobject
    bhkWorldObject

struct bhkShapePhantom //niobject
    bhkWorldObject

struct bhkEntity //niobject
    bhkWorldObject

struct bhkSimpleShapePhantom //niobject
    bhkWorldObject
    float Unknown1[7]
    float Unknown2[3][5]
    float Unknown3

struct bhkRigidBody //niobject
    bhkWorldObject
    int            Unknown1
    int            Unknown2
    int            Unknown3[3]
    hkResponseType CResponse
    byte           Unknown4
    ushort         ProcessContactCallbackDelay
    ushort         Unknown5[2]
    HavokColFilter HavokColFilterCopy
    ushort         Unknown6[6]
    Vector4        Translation
    QuaternionXYZW Rotation
    Vector4        LinearVelocity
    Vector4        AngularVelocity
    InertiaMatrix  Inertia
    Vector4        Center
    float Mass
    float LinearDamping
    float AngularDamping
    float UnknownFactor1 (UVersion >= 12)
    float UnknownFactor2 (UVersion >= 12)
    float Friction
    float RollingFrictionMultiplier (UVersion >= 12)
    float Restitution
    float MaxLinearVelocity
    float MaxAngularVelocity
    float PenetrationDepth
    MotionSystem       MSystem
    DeactivatorType    DType
    SolverDeactivation SDeactivation
    MotionQuality      QType
    uint   Unknown7[3]
    uint   Unknown8          (UVersion >= 12) // "Skyrim only"
    Ref    Constraints[uint] // bhkSerializable
    uint   Unknown9          (UVersion <= 11)
    ushort Unknown10         (UVersion >= 12)

struct bhkRigidBodyT //niobject
    bhkRigidBody

struct bhkConstraint //niobject // "Describes a physical constraint"
    Ptr  Entities[uint] // bhkEntity
    uint Priority

struct bhkLimitedHingeConstraint //niobject
    bhkConstraint
    LimitedHingeDescriptor

struct bhkMalleableConstraint //niobject
    bhkConstraint
    SubConstraint
    float Tau      (Version <= 0x14000005)
    float Damping  (Version <= 0x14000005)
    float Strength (Version >= 0x14020007)

struct bhkStiffSpringConstraint //niobject
    bhkConstraint
    StiffSpringDescriptor

struct bhkRagdollConstraint //niobject
    bhkConstraint
    RagdollDescriptor

struct bhkPrismaticConstraint //niobject
    bhkConstraint
    PrismaticDescriptor

struct bhkHingeConstraint //niobject
    bhkConstraint
    HingeDescriptor

struct bhkBallAndSocketConstraint //niobject
    bhkConstraint
    BallAndSocketDescriptor

struct bhkBallSocketConstraintChain //niobject
    Vector4 Floats[uint]
    float   Unknown1
    float   Unknown2
    uint    Unknown3
    uint    Unknown4
    Ptr     Links[uint]
    Ptr     Links2[uint]
    uint    Unknown5

struct bhkTransformShape //niobject
    Ref           Shape // bhkShape
    HavokMaterial Material
    float         Unknown1
    byte          Unknown2[8]
    Matrix44      Transform

struct bhkSphereRepShape //niobject
    HavokMaterial Material
    float         Radius

struct bhkConvexShape //niobject
    bhkSphereRepShape

struct bhkSphereShape //niobject
    bhkSphereRepShape

struct bhkCapsuleShape //niobject
    bhkSphereRepShape
    byte    Unknown[8]
    Vector3 First
    float   Radius
    Vector3 Second
    float   Radius2

struct bhkBoxShape //niobject
    bhkSphereRepShape
    byte    Unknown[8]
    Vector3 Dimensions
    float   MinSize

struct bhkConvexVerticesShape //niobject
    bhkSphereRepShape
    float   Unknown[6]
    Vector4 Vertices[uint]
    Vector4 Normals[uint]

struct bhkConvexTransformShape //niobject
    bhkTransformShape

struct bhkMultiSphereShape //niobject
    bhkSphereRepShape
    float    Unknown[2]
    SphereBV Spheres[uint]

// struct bhkBvTreeShape inherit="bhkShape" //niobject

// "Memory optimized partial polytope bounding volume tree shape (not an
// entity)"
struct bhkMoppBvTreeShape //niobject
    Ref     Shape // bhkShape
    uint    Unknown1
    byte    Unknown2[8]
    float   Unknown3
    uint    MOPPDataSize
    Vector3 Origin
    float   Scale
    byte    OldMOPPData[MOPPDataSize] (Version <= 0x0a000100)
    MoppDataBuildType BuildType ((Version >= 0x14020007) && (UVersion >= 12))
    byte    MOPPData[MOPPDataSize] (Version >= 0x0a000102)

// struct bhkShapeCollection inherit="bhkShape" //niobject

struct bhkListShape //niobject
    Ref           SubShapes[uint] // bhkShape
    HavokMaterial Material
    float         Unknown1[6]
    uint          Unknown2[uint]

// Caution: "the 4 dummy separator bytes seem to be missing from nifs that have
// this block"
struct bhkMeshShape //niobject
    float Unknown1[9]
    float Unknown2[int][3]
    int   Unknown3[3]
    Ref   StripsData[uint] (Version >= 0x0a000100) // NiTriStripsData

// "A shape constructed from strips data"
struct bhkPackedNiTriStripsShape //niobject
    OblivionSubShape SubShapes[ushort] (Version <= 0x14000005)
    uint    Unknown1[2]
    float   Unknown2
    uint    Unknown3
    Vector3 ScaleCopy
    float   Unknown4
    float   Unknown5
    Vector3 Scale
    float   Unknown6
    Ref     Data // hkPackedNiTriStripsData

struct bhkNiTriStripsShape //niobject
    HavokMaterial Material
    float   Unknown1
    uint    Unknown2
    uint    Unknown3[4]
    uint    Unknown4
    Vector3 Scale
    uint    Unknown5
    Ref     StripsData[uint] // NiTriStripsData
    HavokColFilter DataLayers[uint]

// struct NiInterpolator inherit="NiObject" //niobject
// struct NiKeyBasedInterpolator inherit="NiObject" //niobject

// Here: using FooInterpolator<T>? - is it really worth it?
// T has to be transformed:
//   1. read "NiFloatInterpolator"
//   2. there is no such struct -> find() returns nullptr
//   3. find what? - a pattern: Ni<T>Interpolator <=> map to FooInterpolator<T>
//   4. extract "Float" from "NiFloatInterpolator"
//   5. generate FooInterpolator<Float>
// Really? So much code == "6 lines into 2" at the ML? I don't think so. The
// trade-off is a big no-no.
struct NiFloatInterpolator //niobject
    float Value
    Ref   Data // NiFloatData

struct NiTransformInterpolator //niobject
    Transform<Quaternion>
    byte Unknown1[3] (Version == 0x0a01006a)
    Ref  Data // NiTransformData

struct NiPoint3Interpolator //niobject
    Vector3 Value
    Ref     Data // NiPosData

struct NiPathInterpolator //niobject
    ushort Unknown1
    uint   Unknown2
    float  Unknown3[2]
    ushort Unknown4
    Ref    PosData   // NiPosData
    Ref    FloatData // NiFloatData

struct NiBoolInterpolator //niobject
    bool Value
    Ref  Data // NiBoolData

struct NiBoolTimelineInterpolator //niobject
    NiBoolInterpolator

struct NiBlendInterpolator //niobject
    ushort Unknown1
    uint   Unknown2

struct NiBSplineInterpolator //niobject
    float StartTime
    float StopTime
    Ref   SplineX     // NiBSplineData TODO spline what?
    Ref   SplineBasis // NiBSplineBasisData

// One object to rule them all
struct NiObjectNET //niobject
    // Not an issue after the split.
    //TODO not implementing a bad idea: cond="BSLightingShaderProperty"
    // introduced by 0c5fed4290a04086a0b17d312fd7f49688f87940
    // just setting the impossible condition disables it
    BSLightingShaderPropertyShaderType DetectMe (UVersion >= 123456781)
    String Name
    bool   HasOldExtraData    (Version <= 0x02030000)
    String OldExtraPropName   (HasOldExtraData)
    uint   OldExtraInternalId (HasOldExtraData)
    String OldExtraString     (HasOldExtraData)
    byte   Unknown1           (Version <= 0x02030000)
    // NiExtraData
    Ref    ExtraData        ((Version >= 0x03000000) && (Version <= 0x04020200))
    Ref    ExtraDataList[uint] (Version >= 0x0a000100)
    Ref    Controller          (Version >= 0x03000000) // NiTimeController

struct NiCollisionObject //niobject
    Ptr Target // NiAVObject

struct NiCollisionData //niobject
    NiCollisionObject
    PropagationMode PMode
    CollisionMode   CMode (Version >= 0x0a010000)
    byte            UseABV
    BoundingVolume  BV (UseABV == 1) // can't be "bool" because it varies

struct bhkNiCollisionObject //niobject
    NiCollisionObject
    Flags Flags //LATER docs pass
    Ref   Body

struct bhkCollisionObject //niobject
    bhkNiCollisionObject //TODO implement recursive composition

struct bhkBlendCollisionObject //niobject
    bhkNiCollisionObject
    float Unknown[2]

struct bhkPCollisionObject //niobject
    bhkNiCollisionObject

struct bhkSPCollisionObject //niobject
    bhkNiCollisionObject /*TODO these require something: they're the same thing
                                named differently; value list of string literals
                                perhaps */

struct NiAVObject //niobject
    NiObjectNET
    Flags   Flags    (Version >= 0x03000000)
    ushort  Unknown1 ((Version >= 0x14020007)
                     && (UVersion >= 11) && (UVersion2 > 26))
    Transform<Matrix33> Transform
    Vector3 Velocity         (Version <= 0x04020200)
    Ref     Properties[uint] ((Version < 0x14020007) || (UVersion <= 11))
    uint    Unknown1[4]      (Version <= 0x02030000)
    byte    Unknown2         (Version <= 0x02030000)
    BoundingBox BB ((bool)
                   && (Version >= 0x03000000) && (Version <= 0x04020200))
    Ref CObject (Version >= 0x0a000100) // NiCollisionObject

// "A dynamic effect such as a light or environment map"
struct NiDynamicEffect //niobject
    NiAVObject
    bool SwitchState (Version >= 0x0a01006a)
    uint AffectedNodeListPointers[uint] (Version <= 0x04000002)
    Ref  AffectedNodes[uint] (Version >= 0x0a010000) // NiAVObject

struct NiLight // "Light source" //niobject
    NiDynamicEffect
    float Dimmer
    Color3 Colors[3] // Ambient, Diffuse, Specular

struct NiProperty //niobject
    NiObjectNET

struct NiTransparentProperty //niobject
    NiProperty
    byte Unknown[6]

struct NiPSysModifier // "Generic particle system modifier object" //niobject
    String Name
    uint   Order
    Ptr    Target // NiParticleSystem
    bool   Active

struct NiPSysEmitter //niobject
    NiPSysModifier
    float Speed
    float SpeedVariation
    float Declination
    float DeclinationV
    float PlanarAngle
    float PlanarAngleV
    Color4 Color
    float Radius
    float RadiusV (Version >= 0x0a040001)
    float LifeSpan
    float LifeSpanV

struct NiPSysVolumeEmitter //niobject
    NiPSysEmitter
    Ptr EmitterObject (Version >= 0x0a010000) // NiNode

struct NiTimeController //niobject
    Ref   NextController // NiTimeController
    Flags Flags /* "Bit 0 : Anim type, 0=APP_TIME 1=APP_INIT
                   Bit 1-2 : Cycle type  00=Loop 01=Reverse 10=Loop
                   Bit 3 : Active
                   Bit 4 : Play backwards" */
    float Frequency
    float Phase
    float StartTime
    float StopTime
    Ptr   Target   (Version >= 0x0303000D) // NiObjectNET
    uint  Unknown1 (Version <= 0x03010000)

struct NiInterpController //niobject
    NiTimeController

struct NiMultiTargetTransformController //niobject
    NiInterpController
    Ptr ExtraTargets[ushort] // NiAVObject

struct NiGeomMorpherController //niobject
    NiInterpController
    Flags ExtraFlags (Version >= 0x0a000102)
    byte  Unknown1   (Version == 0x0a01006a)
    Ref   Data // NiMorphData
    byte  AlwaysUpdate
    uint  INum       (Version >= 0x0a01006a)
    Ref Interpolators[INum] ((Version >= 0x0a01006a) && (Version <= 0x14000005))
    MorphWeight IWeights[INum] (Version >= 0x14010003)
    uint Unknown2[uint] ((Version >= 0x14000004) && (Version <= 0x14000005)
                        && (UVersion >= 10))

struct NiMorphController //TODO alias //niobject
    NiInterpController

struct NiMorpherController //niobject
    NiInterpController
    Ref Data // NiMorphData

struct NiSingleInterpController //niobject
    NiInterpController
    Ref Interpolator (Version >= 0x0a020000) // NiInterpolator

struct NiKeyframeController //niobject
    NiSingleInterpController
    Ref Data (Version <= 0x0a010000) // NiKeyframeData

struct NiTransformController //niobject
    NiKeyframeController

struct NiPSysModifierCtlr //niobject
    NiSingleInterpController
    String Name

struct NiPSysEmitterCtlr //niobject
    NiPSysModifierCtlr
    Ref Data (Version <= 0x0a010000) // NiPSysEmitterCtlrData
    Ref VisibilityInterpolator (Version >= 0x0a020000) // NiInterpolator

// I stopped updating the nif_xml.dia at this point - its a waste of time.

struct NiPSysModifierBoolCtlr //niobject
    NiPSysModifierCtlr

struct NiPSysModifierActiveCtlr //niobject
    NiPSysModifierBoolCtlr
    Ref Data (Version <= 0x0a010000) // NiVisData

struct NiPSysModifierFloatCtlr //niobject
    NiPSysModifierCtlr
    Ref Data (Version <= 0x0a010000) // NiFloatData

// I'm trying to find reason here; and I'm failing.
struct NiPSysEmitterDeclinationCtlr //niobject
    NiPSysModifierFloatCtlr

struct NiPSysEmitterDeclinationVarCtlr //niobject
    NiPSysModifierFloatCtlr

struct NiPSysEmitterInitialRadiusCtlr //niobject
    NiPSysModifierFloatCtlr

struct NiPSysEmitterLifeSpanCtlr //niobject
    NiPSysModifierFloatCtlr

struct NiPSysEmitterSpeedCtlr //niobject
    NiPSysModifierFloatCtlr

struct NiPSysGravityStrengthCtlr //niobject
    NiPSysModifierFloatCtlr

struct NiFloatInterpController //niobject
    NiSingleInterpController

struct NiFlipController // "Texture flipping controller" //niobject
    NiFloatInterpController
    TextureType TextureSlot
    uint Unknown1 ((Version >= 0x04000000) && (Version <= 0x0a010000))
    float Delta (Version <= 0x0a010000)
    Ref Sources[uint] (Version >= 0x04000000) // NiSourceTexture
    Ref Images[uint] (Version <= 0x03010000) // NiImage

struct NiAlphaController // "Time controller for transparency" //niobject
    NiFloatInterpController
    Ref Data (Version >= 0x0a010000) // NiFloatData

struct NiTextureTransformController //niobject
    NiFloatInterpController
    byte             Unknown
    TextureType      TextureSlot
    TextureTransform Operation
    Ref              Data (Version >= 0x0a010000) // NiFloatData

struct NiLightDimmerController //niobject
    NiFloatInterpController

struct NiBoolInterpController //niobject
    NiSingleInterpController

struct NiVisController //niobject
    NiBoolInterpController
    Ref Data (Version >= 0x0a010000) // NiVisData

struct NiPoint3InterpController //niobject
    NiSingleInterpController
    TargetColor Color (Version >= 0x0a010000)
    Ref         Data  (Version >= 0x0a010000) // NiPosData

struct NiMaterialColorController //niobject
    NiPoint3InterpController

struct NiLightColorController //niobject
    NiPoint3InterpController

struct NiExtraDataController //niobject
    NiSingleInterpController

struct NiFloatExtraDataController //niobject
    NiExtraDataController
    String ControllerData (Version >= 0x0a020000)
    byte   BNum           (Version <= 0x0a010000)
    byte   Unknown1[7]    (Version <= 0x0a010000)
    byte   Unknown2[BNum] (Version <= 0x0a010000)

struct NiBoneLODController //niobject
    NiTimeController
    uint Unknown1
    uint GNum1
    uint GNum2 // unused ??
    NodeGroup NGroups[GNum1]
    SkinShapeGroup SGroups1[uint] (((Version >= 0x04020200) && (UVersion == 0))
        || ((Version == 0x0a020000) && (UVersion == 1)))
    Ref SGroups2[uint] (((Version >= 0x04020200) && (UVersion == 0))
        || ((Version == 0x0a020000) && (UVersion == 1))) // NiTriBasedGeom
    int Unknown2[2] ((Version == 0x14030009) && (UVersion == 131072))

struct NiBSBoneLODController //niobject
    NiBoneLODController

// "Describes a visible scene element with vertices like a mesh, a particle
// system, lines, etc"
struct NiGeometry //niobject
    NiAVObject
    Ref Data // NiGeometryData
    Ref SkinInstance (Version >= 0x0303000D) // NiSkinInstance
    // See: why would you want this:
    uint   MNum         (Version >= 0x14020007)
    String MName[MNum]  (Version >= 0x14020007)
    int    MEData[MNum] (Version >= 0x14020007)
    int    MActive      (Version >= 0x14020007)
    // when it is in its own ffd, the conditions will be no more.
    //
    bool   HasShader  ((Version >= 0x0a000100) && (Version <= 0x14010003))
    String ShaderName (HasShader)
    int    Unknown1   (HasShader)
    byte   Unknown2   ((UVersion == 1) && (Version == 0x0a020000))
    int    Unknown3   (Version == 0x0a040001)
    bool   Dirty      (Version >= 0x14020007)
    // NiProperty
    Ref    BSProperties[2] ((Version >= 0x14020007) && (UVersion == 12))

struct NiTriBasedGeom //niobject
    NiGeometry

[mesh3d]
struct NiGeometryData // "Mesh data: vertices, vertex normals, etc" //niobject
    int Unknown1 (Verison >= 0x0a020000)
    // cond="!NiPSysData" - I had to consult an undamaged "nif.xml":
    // the damage has been done with 589c2b50c1ac3ec3b131b5957805aadca265e919
    // checked out a0972b3d50be5ae1ef0dc1c21d597712565abb80
    //   using it to restore NiObjectNET above: nope its damaged
    //   further back ... already "fixed" it.
    ushort VNum
    byte   KeepFlags (Version >= 0x0a010000)
    byte   CompressFlags (Version >= 0x0a010000)
    bool   HasVertices
    [mesh3d(vertices)]
    Vector3 Vertices[VNum] (HasVertices)
    byte   UVSetNum   (Version >= 0x0a000100)
    // whats this? - this wasn't here before
    ExtraVectorsFlags X (Version >= 0x0a000100)
    uint   Unknown2 ((Version >= 0x14020007) && (UVersion == 12))
    bool   HasNormals
    [mesh3d(normals)]
    Vector3 Normals[VNum] (HasNormals)
    [mesh3d(noidea_1)]
    Vector3 Tangents[VNum] ((HasNormals) && (X) && (Version >= 0x0a010000))
    [mesh3d(noidea_2)]
    Vector3 Bitangents[VNum] ((HasNormals) && (X) && (Version >= 0x0a010000))
    Vector3 Center
    float   Radius
    short   Unknown3[13] ((Version == 0x14030009) && (UVersion == 131072))
    bool    HasVColors
    [mesh3d(colors)]
    Color4  VColors[VNum] (HasVColors)
    ushort  UVSetNum (Version <= 0x04020200)
    bool    HasUV    (Version <= 0x04000002)
    [mesh3d(uv)]
    TextureCoord UVSets[VNum]
    ConsistencyType CFlags (Version >= 0x0a000100)
    Ref Data (Version >= 0x14000004) // AbstractAdditionalGeometryData

// AbstractAdditionalGeometryData inherit="NiObject" //niobject

struct NiTriBasedGeomData //niobject
    NiGeometryData
    ushort TNum

struct bhkBlendController //niobject
    NiTimeController
    uint Unknown

struct BSBound //niobject
    NiExtraData // this ain't available above
    Vector3 Center
    Vector3 Dimensions

struct BSFurnitureMarker //niobject
    NiExtraData
    FurniturePosition Positions[uint]

struct BSParentVelocityModifier //niobject
    NiPSysModifier
    float Damping

struct BSPSysArrayEmitter //niobject
    NiPSysVolumeEmitter

struct BSWindModifier //niobject
    NiPSysModifier
    float Strength

struct hkPackedNiTriStripsData //niobject
    bhkShapeCollection
    hkTriangle Triangles[uint]
    uint       VNum
    byte       Unknown (Version >= 0x14020007)
    Vector3    Vertices[VNum]
    OblivionSubShape SubShapes[ushort] (Version >= 0x14020007)

struct NiAlphaProperty //niobject
    NiProperty
    Flags  Flags
    byte   Threshold
    ushort Unknown1 (Version <= 0x02030000)
    uint   Unknown2 (Version <= 0x02030000)

struct NiAmbientLight //niobject
    NiLight

struct NiParticlesData //niobject
    NiGeometryData
    ushort PNum (Version <= 0x04000002)
    float Radius (Version <= 0x0a000100)
    bool HasRadii (Version >= 0x0a010000)
    float Radii[VNum] ((HasRadii)
        && !((Version >= 0x14020007) && (UVersion >= 11)))
    ushort ANum
    bool   HasSizes
    float  Sizes[VNum] ((HasSizes)
        && !((Version >= 0x14020007) && (UVersion >= 11)))
    bool HasRotations (Version >= 0x0a000100)
    Quaternion Rotations[VNum] ((HasRotations)
        && !((Version >= 0x14020007) && (UVersion >= 11)))
    byte Unknown1 ((Version >= 0x14020007) && (UVersion >= 12))
    Ref  Unknown2 ((Version >= 0x14020007) && (UVersion >= 12))
    bool HasAngles (Version >= 0x14000004)
    float RAngles[VNum] ((HasRAngles)
        && !((Version >= 0x14020007) && (UVersion >= 11)))
    // I sense a pattern here; do you?
    bool HasRAxes (Version >= 0x14000004)
    Vector3 RAxes[VNum] ((HasRAngles)
        && !((Version >= 0x14020007) && (UVersion >= 11)))
    bool HasUVQ (Version >= 0x14000004)
    Vector4 UVQs[byte] ((HasUVQ)
        && !((Version >= 0x14020007) && (UVersion == 11)))
    byte Unknown3 ((Version >= 0x14020007) && (UVersion >= 11))

struct NiRotatingParticlesData //niobject
    NiParticlesData
    Quaternion Rotations2[VNum] ((bool) && (Version <= 0x04020200))

struct NiAutoNormalParticlesData //niobject
    NiParticlesData

struct ParticleDesc // compound
    Vector3 Translation
    float   Unknown1[3] (Version <= 0x0a040001)
    float   Unknown2[3]
    int     Unknown3

// The reason for the damage on NiGeometryData
struct NiPSysData //niobject
    NiRotatingParticlesData
    ParticleDesc PD[VNum] (!((Version >= 0x14020007) && (UVersion >= 11)))
    //TODO handle all these duplicate names
    float  Unknown1[VNum] ((bool) && (Version >= 0x14000004)
                          && !((Version >= 0x14020007) && (UVersion >= 11)))
    ushort Unknown2[2] (!((Version >= 0x14020007) && (UVersion >= 11)))
    bool   HasSOUV ((Version >= 0x14020007) && (UVersion >= 12))
    uint   NumSOUV (HasSOUV)
    float  ARatio  ((Version >= 0x14020007) && (UVersion >= 12))
    Vector4 SOUV[NumSOUV] ((HasSOUV)
        && (Version >= 0x14020007) && (UVersion >= 12))
    uint   Unknown3[3] ((Version >= 0x14020007) && (UVersion >= 12))
    ushort Unknown4 ((Version >= 0x14020007) && (UVersion >= 12))
    byte   Unknown5 ((Version >= 0x14020007) && (UVersion >= 12))

struct NiPSysData_a0972b3d50be5ae1ef0dc1c21d597712565abb80
    NiRotatingParticlesData
    ParticleDesc PD[VNum] (!((Version >= 0x14020007) && (UVersion >= 11)))
    float  Unknown1[VNum] ((bool) && (Version >= 0x14000004)
                          && !((Version >= 0x14020007) && (UVersion >= 11)))
    ushort Unknown2[2] (!((Version >= 0x14020007) && (UVersion >= 11)))
    // a very odd difference
    byte   Unknown3 ((Version >= 0x14020007) && (UVersion >= 12))
    ushort Unknown2[2] (!((Version >= 0x14020007) && (UVersion >= 12)))
    //
    bool   HasVC ((Version >= 0x14020007) && (UVersion >= 12))
    uint   NumVC (HasVC)
    uint   Unknown4 ((Version >= 0x14020007) && (UVersion >= 12))
    Color4 VC[NumVC] ((HasVC)
        && (Version >= 0x14020007) && (UVersion >= 12))
    uint Unknown5[5] ((Version >= 0x14020007) && (UVersion >= 12))
    ushort Unknown4 ((Version >= 0x14020007) && (UVersion >= 12))
    byte   Unknown5 ((Version >= 0x14020007) && (UVersion >= 12))

struct NiMeshPSysData //niobject
    NiPSysData
    uint Unknown1 (Version >= 0x0a020000)
    byte Unknown2 (Version >= 0x0a020000)
    uint Unknown3[uint] (Version >= 0x0a020000)
    Ref  Unknown4

struct NiBinaryExtraData //niobject
    NiExtraData
    ByteArray Data

struct NiBinaryVoxelExtraData //niobject
    NiExtraData
    uint Unknown
    Ref  Data // NiBinaryVoxelData

struct NiBinaryVoxelData //niobject
    ushort  Unknown1[3] //LATER implement some auto-naming
    float   Unknown2[7][12]
    Vector4 Unknown3[uint]
    byte    Unknown4[uint]
    uint    Unknown5[5]

struct NiBlendBoolInterpolator //niobject
    NiBlendInterpolator
    byte Value

struct NiBlendFloatInterpolator //niobject
    NiBlendInterpolator
    float Value

struct NiBlendPoint3Interpolator //niobject
    NiBlendInterpolator
    Vector3 Value

struct NiBlendTransformInterpolator //niobject
    NiBlendInterpolator

struct NiBoolData //niobject
    KeyGroup<byte> Data

struct NiBooleanExtraData //niobject
    NiExtraData
    byte Data

struct NiBSplineBasisData //niobject
    uint CPNum

struct NiBSplineFloatInterpolator //niobject
    NiBSplineInterpolator

struct NiBSplineCompFloatInterpolator //niobject
    NiBSplineFloatInterpolator
    float Base
    uint  Offset
    float Bias
    float Multiplier

struct NiBSplinePoint3Interpolator //niobject
    NiBSplineInterpolator
    float Unknown[6]

struct NiBSplineCompPoint3Interpolator //niobject
    NiBSplinePoint3Interpolator

struct NiBSplineTransformInterpolator //niobject
    NiBSplineInterpolator
    Transform<Quaternion> Transform
    uint TranslationOffset
    uint RotationOffset
    uint ScaleOffset

struct NiBSplineCompTransformInterpolator //niobject
    NiBSplineTransformInterpolator
    float TranslationBias
    float TranslationMultiplier
    float RotationBias
    float RotationMultiplier
    float ScaleBias
    float ScaleMultiplier

struct BSRotAccumTransfInterpolator //niobject
    NiTransformInterpolator

struct NiBSplineData //niobject
    float FloatControlPoints[uint]
    short ShortControlPoints[uint]

struct NiCamera //niobject
    NiAVObject
    ushort Unknown1 (Version >= 0x0a010000)
    float  Frustum[6] // Left,Right,Top,Bottom,Near,Far
    bool   UseOrtho (Version >= 0x0a010000)
    float  Viewport[4] // Left,Right,Top,Bottom
    float  LODAdjust
    Ref    Unknown2
    uint   Unknown3
    uint   Unknown4 (Version >= 0x04020100)
    uint   Unknown5 (Version <= 0x03010000)

struct NiColorData //niobject
    KeyGroup<Color4> Data

struct NiColorExtraData //niobject
    NiExtraData
    Color4 Data

struct NiControllerManager //niobject
    NiTimeController
    bool Cumulative
    Ref  ControllerSequences[uint] // NiControllerSequence
    Ref  ObjectPalette // NiDefaultAVObjectPalette

struct NiSequence //niobject
    String Name
    String KeyNames (Version <= 0x0a010000)
    Ref    Keys (Version <= 0x0a010000) // NiTextKeyExtraData
    int    Unknown1[2] ((Version == 0x14030009) && (UVersion == 131072))
    uint   CBNum
    uint   Unknown2 (Version >= 0x0a01006a)
    ControllerLink CBlocks[CBNum]

struct NiControllerSequence //niobject
    NiSequence
    float Weight    (Version >= 0x0a01006a)
    Ref   Keys      (Version >= 0x0a01006a) // NiTextKeyExtraData
    CycleType CType (Version >= 0x0a01006a)
    uint  Unknown1  (Version == 0x0a01006a)
    float Frequency (Version >= 0x0a01006a)
    float StartTime (Version >= 0x0a01006a)
    float Unknown2  ((Version >= 0x0a020000) && (Version <= 0x0a040001))
    float StopTime  (Version >= 0x0a01006a)
    byte  Unknown3  (Version == 0x0a01006a)
    Ptr   Manager   (Version >= 0x0a01006a) // NiControllerManager
    String TargetName (Version >= 0x0a01006a)
    Ref   StringPalette ((Version >= 0x0a020000) && (Version <= 0x14000005))
    Ref   AnimNotes ((Version >= 0x14020007) && (UVersion >= 11)
                    && (UVersion2 >= 24) && (UVersion2 <= 28))
    short Unknown4 ((Version >= 0x14020007) && (UVersion >= 11)
                   && (UVersion2 > 28))
    uint  Unknown5  (Version >= 0x14030009)

// NiAVObjectPalette inherit="NiObject"

struct NiDefaultAVObjectPalette //niobject
    uint Unknown
    AVObject Objs[uint]

struct NiDirectionalLight //niobject
    NiLight

struct NiDitherProperty //niobject
    NiProperty
    Flags Flags

struct NiRollController //niobject
    NiSingleInterpController
    Ref Data // NiFloatData

struct NiFloatData //niobject
    KeyGroup<float> Data

struct NiFloatExtraData //niobject
    NiExtraData
    float Data

struct NiFloatsExtraData //niobject
    NiExtraData
    float Data[uint]

struct NiFogProperty //niobject
    NiProperty
    Flags  Flags
    float  Depth
    Color3 Color

struct NiGravity //niobject
    NiParticleModifier
    float     Unknown (Version >= 0x04000002)
    float     Force
    FieldType Type
    Vector3   Position
    Vector3   Direction

struct NiIntegerExtraData //niobject
    NiExtraData
    uint Data

struct BSXFlags //niobject
    NiIntegerExtraData /*"Controls animation and collision. Integer holds flags:
        Bit 0 : enable havok, bAnimated(Skyrim)
        Bit 1 : enable collision, bHavok(Skyrim)
        Bit 2 : is skeleton nif?, bRagdoll(Skyrim)
        Bit 3 : enable animation, bComplex(Skyrim)
        Bit 4 : FlameNodes present, bAddon(Skyrim)
        Bit 5 : EditorMarkers present
        Bit 6 : bDynamic(Skyrim)
        Bit 7 : bArticulated(Skyrim)
        Bit 8 : bIKTarget(Skyrim)
        Bit 9 : Unknown(Skyrim)" */

struct NiIntegersExtraData //niobject
    NiExtraData
    uint Data[uint]

struct BSKeyframeController //niobject
    NiKeyframeController
    Ref Data2 // NiKeyframeData

struct NiKeyframeData //niobject
    uint              RKNum
    KeyType           RType           (RKNum)
    QuatKey<RType>    QKeys[RKNum]    (RType != 4)
    float             Unknown1        ((RType == 4) && (Version <= 0x0a010000))
    KeyGroup<float>   XYZRotations[3] (RType == 4)
    KeyGroup<Vector3> Translation
    KeyGroup<float>   Scale

struct NiLookAtController //niobject
    NiTimeController
    ushort Unknown1 (Version >= 0x0a010000)
    Ptr    LookAt

struct NiLookAtInterpolator //niobject
    NiInterpolator
    ushort Unknown1
    Ptr    LookAt
    String Target
    Transform<Quaternion> Transform (Version >= 0x14050000)
    Ref    Unknown2[3] // NiPoint3Interpolator

struct NiMaterialProperty //niobject
    NiProperty
    Flags  Flags (Version >= 0x03000000) && (Version <= 0x0a000102)
    Color3 Ambient (!((Version == 0x14020007) && (UVersion >= 11)
                   && (UVersion2 > 21)))
    Color3 Diffuse (!((Version == 0x14020007) && (UVersion >= 11)
                   && (UVersion2 > 21)))
    Color3 Specular
    Color3 Emissive
    float  Glossiness
    float  Alpha
    float  EmitMulti (!((Version == 0x14020007) && (UVersion >= 11)
                     && (UVersion2 > 21)))
